.Dd June 01, 2025
.Dt BMATH 1
.Os
.Sh NAME
.Nm bmath
.Nd prints result of some bitwise expression in a pretty format
.Sh SYNOPSIS
.Nm
.Op Fl a Ar <EXPRESSION>
.Op Fl b
.Op Fl u
.Op Fl -unicode
.Op Ar EXPRESSION
.Nm
.Op Fl a Ar <EXPRESSION>
.Op Fl b
.Op Fl u
.Op Fl -unicode
.Ar -w \fI<FILE>\fR
.Nm
.Op Fl -help
.Nm
.Op Fl -usage
.Nm
.Op Fl V
.Sh DESCRIPTION
.Pp
Prints the result of some bitwise \fIEXPRESSION\fR. These are parsed through \fIEXPRESSION\fR, \fBstdin\fR, \fBlive-edit\fR, or \fBinteractive\fR modes. The default mode is \fBinteractive\fR.
.Pp
Interactive mode can be exited by typing \fIexit\fR or \fIquit\fR.
.Sh OPTIONS
.Bl -tag -width Ds
.It Fl a\ \fI<EXPRESSION>\fR, Fl -align=\fI<EXPRESSION>\fR
Takes the evauluation from the \fIEXPRESSION\fR, \fBstdin\fR, \fBlive-edit\fR, or \fBinteractive\fR modes, and then aligns the output to the alignment expression. It helps if this alignment is a power of 2, but it's not enforced. Otherwise, all evaulation logic applies to the alignment expression.
.It Fl b
Appends binary representation of result to output.
.It Fl -help
Prints help information.
.It Fl u, Fl -uppercase
Prints hexadecimal output in uppercase.
.It Fl -unicode
Appends unicode representation of result to output in UTF-8, 16, and 32 forms.
.It Fl -usage
Prints usage message.
.It Fl V, Fl -version
Prints program version.
.It Fl w, Fl -watch
Watches file for changes. ie. \fBlive-edit\fR mode. Requires a path to a file to watch as the first positional argument.
.El
.Sh EXPRESSION
.Bd -literal
expr = signed, op, signed
     | signed ;
signed = number
       | lparen, expr, rparen
       | { logic_not | sign }, signed
       | function
function = function_name, lparen, expr, {",", expr }, rparen
number = digit, { digit }
       | hex ;
digit = [0-9], { [0-9] } ;
hex = "0x", [0-9a-fA-F], { [0-9a-fA-F] } ;
op = "|" | "^" | "&" | "<<" | ">>" | "-" | "+" | "*" | "/" | "%" ;
lparen = "(" ;
rparen = ")" ;
logic_not = "~" ;
sign = "-" | "+" ;

Functions:
align(x, align_to)
    Aligns x to align_to. align_to should be a power of two, but is not
    enforced.

align_down(x, align_to)
    Same as align() except the result is rounded down to nearest alginment.

bswap(x)
    Swaps the byte order of x. 16, 32, and 64 modes are supported respectfully.

clz(x, num_bytes)
    Counts number of zeros before the first 1, according to num_bytes.
    num_bytes must be in range of [1, 8].
    Example:
      x = 1, num_bytes = 8, expect result 63. If num_bytes = 1, expect 7.

ctz(x)
    Counts number of zeros after the last 1.
    Example:
      x = 1, expect result 0. If x = (1 << 63), expect 63.

mask(num_bytes)
    Creates a mask of num_bytes. num_bytes must be in range of [0, 8].

popcnt(x)
    Counts the number of 1's set in x.

Order of operations:
+-------------+
| 1 | *, /, % |
+-------------+
| 2 | +, -    |
+---+---------+
| 3 | <<, >>  |
+---+---------+
| 4 | &       |
+---+---------+
| 5 | ^       |
+---+---------+
| 6 | |       |
+---+---------+
.Ed
.Sh EXAMPLES
.Bd -literal
$ echo "1 << 17" | bmath
1 << 17
  Dec: 131072
 Char: Exceeded
  Hex: 0x20000
Hex16: Exceeded
Hex32: 0x00020000
Hex64: 0x0000000000020000

$ bmath --unicode -b "0xff"
   u64: 255
    i8: -1
 UTF-8: ÿ (0xc3bf)
UTF-16: ÿ (0x00ff)
UTF-32: ÿ (0x000000ff)
   Hex: 0xff
 Hex16: 0x00ff
 Hex32: 0x000000ff
 Hex64: 0x00000000000000ff
00000000 00000000 00000000 00000000
00000000 00000000 00000000 11111111

$ bmath
expr> 0xff
   u64: 255
    i8: -1
  char: Exceeded
   Hex: 0xff
 Hex16: 0x00ff
 Hex32: 0x000000ff
 Hex64: 0x00000000000000ff
expr> 0x0f
   u64: 15
    i8: 15
  char: <special>
   Hex: 0xf
 Hex16: 0x000f
 Hex32: 0x0000000f
 Hex64: 0x000000000000000f
expr> exit
.Ed
.Sh AUTHOR
Written by Frederick Lawler <me@fred.software>
.Sh REPORTING BUGS
Report any bugs to <https://github.com/fredlawl/bmath>
